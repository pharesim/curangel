#!/usr/bin/python3
# -*- coding: UTF-8 -*-

import cgi
import time
import datetime
import uuid

from steem.steem import Steem
from steem.blockchain import Blockchain
from steem.account import Account

from lib import db
from lib import api
from lib import errorHandler

from lib.rate_limit import Enforcer, RateLimitError
from lib.db_util import QueueDBHelper


steemd_nodes = [
  'https://anyx.io',
  'https://api.steemit.com',
  'https://steemd.minnowsupportproject.org',
]

client = Steem(nodes=steemd_nodes)
chain = Blockchain(client)

# output variable
data = {}

# get and set variables
form     = cgi.FieldStorage()
username = form.getvalue('username')
userhash = form.getvalue('userhash')
postlink = form.getvalue('postlink')
deleteuv = form.getvalue('deleteupvote')

# check permissions
results = db.select('users',['id'],{'account':username,'hash':userhash,'curator':1},'id')
if len(results) < 1:
  errorHandler.throwError('No permission')

# delete post
if deleteuv:
  post = db.select('upvotes',['status'],{'account':username,'id':deleteuv},'status')
  if len(results) < 1:
    errorHandler.throwError('Upvote not found!')
  db.update('upvotes',{'status': 'canceled'},{'id':deleteuv})
  data['status'] = 'success'
else:
  # submit new post
  if postlink:
    link = postlink.split('#')
    if len(link) > 1:
      link = link[1].split('/')
    else:
      link = postlink.split('/')

    post = client.get_content(link[-2][1:],link[-1])
    chaininfo = chain.info()

    # check if curator is author himself
    if post['author'] == username:
      errorHandler.throwError('Curating your own post? Are you serious?')

    # check if curator is author himself
    if post['author'] == 'curangel':
      errorHandler.throwError('We do not vote for ourselves :D')

    # check if author used bitbots
    bidbots = ['alfanso','appreciator','bdvoter','bid4joy','boomerang','booster','brandonfrye','buildawhale','edensgarden','inciter','joeparys','leo.voter','luckyvotes','minnowbooster','minnowhelper','minnowvotes','ocdb','onlyprofitbot','postpromoter','profitvote','promobot','qustodian','redlambo','rocky1','sct.voter','smartmarket','smartsteem','sneaky-ninja','sportsvoter','spydo','steemyoda','thebot','therising','tipu','treeplanter','triplea.bot','upmewhale','upmyvote','whalepromobot']
    account = Account(post['author'],client)
    history = account.get_account_history(-1,2500,filter_by='transfer')
    for h in history:
      if h['to'] in bidbots:
        errorHandler.throwError('User has used a bid bot recently. Will not add to queue.')
      last = h['timestamp']
      txts = time.mktime(datetime.datetime.strptime(h['timestamp'], "%Y-%m-%dT%H:%M:%S").timetuple())
      chaints = time.mktime(datetime.datetime.strptime(chaininfo['time'], "%Y-%m-%dT%H:%M:%S").timetuple())
      if chaints - txts > 60*60*24*7:
        break

    # check if already voted
    for vote in post['active_votes']:
      if vote['voter'] == 'curangel':
        errorHandler.throwError('We already voted on that post.')

    # check if post has a lot of rewards already
    if float(post['pending_payout_value'][:-4]) >= 10:
      errorHandler.throwError('This post has quite a bit of recognition already. Please curate content which really needs a boost, there are many posts which receive next to nothing!')

    # check if exists in upvote queue
    results = db.select('upvotes',['id'],{'user':post['author'],'slug':post['permlink'],'status !': 'canceled'},'id')
    if len(results) > 0:
      errorHandler.throwError('This post has been submitted before. Will not add to queue again.')

    # check if exists in downvote queue
    result = db.select('downvotes',['account'],{'slug':post['permlink'],'status':'wait'},'id')
    if len(result) > 0:
      errorHandler.throwError('Post was already marked for downvote by '+result[0]['account'])

    # check cashout time
    cashoutts = time.mktime(datetime.datetime.strptime(post['cashout_time'], "%Y-%m-%dT%H:%M:%S").timetuple())
    chaints = time.mktime(datetime.datetime.strptime(chaininfo['time'], "%Y-%m-%dT%H:%M:%S").timetuple())
    if cashoutts - chaints < 60*60*36:
      errorHandler.throwError('Cashout of post in less than 36 hours. Will not add to queue.')

    # check blacklist
    results = db.select('blacklist',['reason'],{'user':post['author']},'id')
    if len(results) > 0:
      errorHandler.throwError('Author blacklistet. Reason: '+results[0]['reason']+'. Will not add to queue.')

    # check previous votes for author
    results = db.select('upvotes',['created'],{'user':post['author'],'account':username,'status !':'canceled','created >':"datetime('now','-7 days')"},'created')
    if len(results) > 0:
      errorHandler.throwError('You already submitted a post of this author in the last week. Will not add to queue.')
    results = db.select('upvotes',['created'],{'user':post['author'],'status !':'canceled','created >':"datetime('now','-1 day')",'status !':'canceled'},'created')
    if len(results) > 0:
      errorHandler.throwError('Someone else already submitted a post of this author today. Will not add to queue.')


    # get queue length
    db_path = db.config.config.db.file
    with QueueDBHelper(db_path) as qdbh:
      queue_length = qdbh.query_queue_length()

    # check mana
    try:
      enforcer = Enforcer.from_database_user(db_path, username, chaininfo['head_block_number'])
      allowed_strength, *_ = enforcer.curate(queue_length)
      enforcer.write_to_database(db_path, username, chaininfo['head_block_number'])
    except RateLimitError as e:
      errorHandler.throwError(e.fmt(username))

    upvote_id = uuid.uuid4().hex

    post_type = 1
    if post['parent_author']:
      post_type = 2
    db.insert('upvotes',{'id':upvote_id, 'account':username, 'link': post['url'], 'user': post['author'], 'category': post['category'], 'slug': post['permlink'], 'title': post['title'], 'type': post_type, 'payout': post['cashout_time'], 'status': 'in queue', 'reward_sbd': 0, 'reward_sp': 0})

    with QueueDBHelper(db_path, read_only=False) as qdbh:
      qdbh.upsert_upvote_strength(upvote_id, allowed_strength)

  # get upvotes
  upvotes = []
  results = db.select('upvotes',['id','created','link','user','category','slug','title','type','payout','status','reward_sp'],{'account':username},'created DESC')
  for row in results:
    upvotes.append(dict(row))

  data['upvotes'] = upvotes

api.output(data)
